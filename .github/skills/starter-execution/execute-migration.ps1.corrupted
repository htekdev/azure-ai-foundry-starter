#!/usr/bin/env pwsh
<#
.SYNOPSIS
    Executes the complete Azure DevOps repository migration process.

.DESCRIPTION
    This script orchestrates the entire migration from a monolithic repository structure
    to an organized multi-repository architecture with CI/CD pipelines, service connections,
    and variable groups.
    
    PREREQUISITES (per COPILOT_EXECUTION_GUIDE.md):
    1. Configuration set up using configuration-management skill (REQUIRED FIRST)
    2. Environment validated using environment-validation skill
    3. Azure resources created using resource-creation skill (including Service Principal with federated credentials)
    4. Service Principal AppId must be in migration-config.json under servicePrincipal.appId
    
    WORKFLOW (follows COPILOT_EXECUTION_GUIDE.md Phase 0-4):
    - Phase 0: Configuration (must be completed before running this script)
    - Phase 1: Backup source repository
    - Phase 2: Reorganize repository structure
    - Phase 3: Create Azure DevOps repositories
    - Phase 4: Create service connections (requires SP with federated credentials)
    - Phase 5: Create variable groups
    - Phase 6: Create pipelines (optional - requires code pushed first)
    - Phase 7: Validation

.PARAMETER UseConfig
    Load configuration from migration-config.json

.PARAMETER OrganizationUrl
    Azure DevOps organization URL (e.g., https://dev.azure.com/org-name)

.PARAMETER ProjectName
    Azure DevOps project name

.PARAMETER SourceRepository
    Name of the source monolithic repository

.PARAMETER CreateBackup
    Create backup of source repository before migration (recommended)

.PARAMETER SkipReorganization
    Skip the repository reorganization phase (if already done)

.PARAMETER SkipAzureDevOps
    Skip Azure DevOps repository creation (if already done)

.PARAMETER SkipPipelines
    Skip pipeline creation (if already done)

.PARAMETER SkipValidation
    Skip final validation checks

.PARAMETER OutputReport
    Path to save migration report JSON

.EXAMPLE
    .\execute-migration.ps1 -UseConfig

.EXAMPLE
    .\execute-migration.ps1 -UseConfig -SkipReorganization
#>

[CmdletBinding()]
param(
    [Parameter()]
    [switch]$UseConfig,
    
    [Parameter()]
    [string]$OrganizationUrl,
    
    [Parameter()]
    [string]$ProjectName,
    
    [Parameter()]
    [string]$SourceRepository,
    
    [Parameter()]
    [switch]$CreateBackup = $true,
    
    [Parameter()]
    [switch]$SkipReorganization,
    
    [Parameter()]
    [switch]$SkipAzureDevOps,
    
    [Parameter()]
    [switch]$SkipPipelines,
    
    [Parameter()]
    [switch]$SkipValidation,
    
    [Parameter()]
    [string]$OutputReport = "migration-report-$(Get-Date -Format 'yyyyMMdd-HHmmss').json"
)

# ===== SETUP =====
$ErrorActionPreference = "Stop"
$ProgressPreference = "SilentlyContinue"

# Add Azure CLI and Git to PATH
$env:PATH = "C:\Program Files\Microsoft SDKs\Azure\CLI2\wbin;$env:PATH"
$env:PATH = "C:\Program Files\Git\cmd;$env:PATH"

# Set bearer token for Azure DevOps
$bearerToken = az account get-access-token --resource 499b84ac-1321-427f-aa17-267ca6975798 --query "accessToken" -o tsv
$env:AZURE_DEVOPS_EXT_PAT = $bearerToken

Write-Host "╔══════════════════════════════════════════════════════════════╗" -ForegroundColor Cyan
Write-Host "║        Azure DevOps Repository Migration Execution          ║" -ForegroundColor Cyan
Write-Host "╚══════════════════════════════════════════════════════════════╝" -ForegroundColor Cyan
Write-Host ""

# ===== LOAD CONFIGURATION =====
$config = $null
if ($UseConfig) {
    # Use correct config path relative to skills directory
    $configPath = "$PSScriptRoot/../migration-config.json"
    if (-not (Test-Path $configPath)) {
        # Try alternate path
        $configPath = Join-Path $PSScriptRoot "..\..\..\..\..\Repos\northwind-systems\repository-migration-project\.github\skills\migration-config.json"
    }
    if (Test-Path $configPath) {
        Write-Host "[Configuration]" -ForegroundColor Yellow
        $config = Get-Content $configPath | ConvertFrom-Json
        $OrganizationUrl = $config.azureDevOps.organizationUrl
        $ProjectName = $config.azureDevOps.projectName
        $SourceRepository = $config.azureDevOps.sourceRepository
        Write-Host "  ✅ Configuration loaded from migration-config.json" -ForegroundColor Green
        Write-Host "  Organization: $OrganizationUrl" -ForegroundColor Gray
        Write-Host "  Project: $ProjectName" -ForegroundColor Gray
        Write-Host "  Source Repo: $SourceRepository" -ForegroundColor Gray
        
        # Load Service Principal info if available
        if ($config.PSObject.Properties.Name -contains "servicePrincipal") {
            Write-Host "  Service Principal: $($config.servicePrincipal.appId)" -ForegroundColor Gray
        }
        Write-Host ""
    }
    else {
        Write-Error "Configuration file not found: $configPath"
    }
}

# Validate required parameters
if (-not $OrganizationUrl -or -not $ProjectName -or -not $SourceRepository) {
    Write-Error "Required parameters missing. Use -UseConfig or specify -OrganizationUrl, -ProjectName, and -SourceRepository"
}

# ===== MIGRATION STATE =====
$migrationState = @{
    startTime = Get-Date
    organizationUrl = $OrganizationUrl
    projectName = $ProjectName
    sourceRepository = $SourceRepository
    phases = @{
        backup = @{ status = "NotStarted"; startTime = $null; endTime = $null; details = @() }
        reorganization = @{ status = "NotStarted"; startTime = $null; endTime = $null; details = @() }
        azureDevOps = @{ status = "NotStarted"; startTime = $null; endTime = $null; details = @() }
        serviceConnections = @{ status = "NotStarted"; startTime = $null; endTime = $null; details = @() }
        variableGroups = @{ status = "NotStarted"; startTime = $null; endTime = $null; details = @() }
        pipelines = @{ status = "NotStarted"; startTime = $null; endTime = $null; details = @() }
        validation = @{ status = "NotStarted"; startTime = $null; endTime = $null; details = @() }
    }
    repositories = @()
    pipelines = @()
    serviceConnections = @()
    variableGroups = @()
    errors = @()
}

function Add-MigrationDetail {
    param(
        [string]$Phase,
        [string]$Message,
        [string]$Status = "Info"
    )
    
    $detail = @{
        timestamp = Get-Date
        message = $Message
        status = $Status
    }
    
    $migrationState.phases.$Phase.details += $detail
    
    $color = switch ($Status) {
        "Success" { "Green" }
        "Error" { "Red" }
        "Warning" { "Yellow" }
        default { "Gray" }
    }
    
    Write-Host "  $Message" -ForegroundColor $color
}

# ===== CONFIGURE AZURE DEVOPS CLI =====
Write-Host "[Azure DevOps Configuration]" -ForegroundColor Yellow
try {
    az devops configure --defaults organization=$OrganizationUrl project=$ProjectName --use-git-aliases true
    Write-Host "  ✅ Azure DevOps CLI configured" -ForegroundColor Green
    Write-Host ""
}
catch {
    Write-Host "  ❌ Failed to configure Azure DevOps CLI: $_" -ForegroundColor Red
    exit 1
}

# ===== PHASE 1: BACKUP =====
if ($CreateBackup) {
    Write-Host "[Phase 1: Backup Source Repository]" -ForegroundColor Yellow
    $migrationState.phases.backup.status = "InProgress"
    $migrationState.phases.backup.startTime = Get-Date
    
    try {
        $backupDir = "$PSScriptRoot/../../../backup-$SourceRepository"
        $backupBranch = "backup-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
        
        if (Test-Path $backupDir) {
            Add-MigrationDetail -Phase "backup" -Message "Backup directory already exists, using existing clone" -Status "Warning"
        }
        else {
            Add-MigrationDetail -Phase "backup" -Message "Cloning source repository..."
            git clone "$OrganizationUrl/$ProjectName/_git/$SourceRepository" $backupDir 2>&1 | Out-Null
            
            if ($LASTEXITCODE -eq 0) {
                Add-MigrationDetail -Phase "backup" -Message "Source repository cloned" -Status "Success"
            }
            else {
                throw "Failed to clone repository"
            }
        }
        
        Push-Location $backupDir
        
        # Create backup branch
        Add-MigrationDetail -Phase "backup" -Message "Creating backup branch: $backupBranch"
        git checkout -b $backupBranch 2>&1 | Out-Null
        git push origin $backupBranch 2>&1 | Out-Null
        
        if ($LASTEXITCODE -eq 0) {
            Add-MigrationDetail -Phase "backup" -Message "Backup branch created and pushed" -Status "Success"
        }
        
        # Create tag
        $backupTag = "migration-backup-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
        Add-MigrationDetail -Phase "backup" -Message "Creating backup tag: $backupTag"
        git tag $backupTag 2>&1 | Out-Null
        git push origin $backupTag 2>&1 | Out-Null
        
        if ($LASTEXITCODE -eq 0) {
            Add-MigrationDetail -Phase "backup" -Message "Backup tag created and pushed" -Status "Success"
        }
        
        Pop-Location
        
        $migrationState.phases.backup.status = "Completed"
        $migrationState.phases.backup.endTime = Get-Date
        $migrationState.backup = @{
            directory = $backupDir
            branch = $backupBranch
            tag = $backupTag
        }
        
        Write-Host "  ✅ Backup completed" -ForegroundColor Green
    }
    catch {
        $migrationState.phases.backup.status = "Failed"
        $migrationState.phases.backup.endTime = Get-Date
        Add-MigrationDetail -Phase "backup" -Message "Backup failed: $_" -Status "Error"
        $migrationState.errors += "Backup phase failed: $_"
        Write-Host "  ❌ Backup failed - migration cannot proceed safely" -ForegroundColor Red
        exit 1
    }
    
    Write-Host ""
}

# ===== PHASE 2: REPOSITORY REORGANIZATION =====
if (-not $SkipReorganization) {
    Write-Host "[Phase 2: Repository Reorganization]" -ForegroundColor Yellow
    $migrationState.phases.reorganization.status = "InProgress"
    $migrationState.phases.reorganization.startTime = Get-Date
    
    try {
        # Get target structure from configuration
        $targetRepos = $config.azureDevOps.targetRepositories
        
        # Handle both string arrays and object arrays
        $repoObjects = @()
        foreach ($repo in $targetRepos) {
            if ($repo -is [string]) {
                # Convert string to object
                $repoObjects += @{
                    name = $repo
                    description = "Repository migrated from $SourceRepository"
                    purpose = "See PROPOSED_STRUCTURE.md for details"
                }
            }
            else {
                $repoObjects += $repo
            }
        }
        
        Add-MigrationDetail -Phase "reorganization" -Message "Target repositories: $($repoObjects.Count)"
        
        # Clone source repository for reorganization
        $workDir = "$PSScriptRoot/../../../work-$SourceRepository"
        
        if (Test-Path $workDir) {
            Add-MigrationDetail -Phase "reorganization" -Message "Work directory exists, cleaning..." -Status "Warning"
            Remove-Item -Path $workDir -Recurse -Force
        }
        
        Add-MigrationDetail -Phase "reorganization" -Message "Cloning source repository for reorganization..."
        git clone "$OrganizationUrl/$ProjectName/_git/$SourceRepository" $workDir 2>&1 | Out-Null
        
        if ($LASTEXITCODE -eq 0) {
            Add-MigrationDetail -Phase "reorganization" -Message "Source cloned successfully" -Status "Success"
        }
        
        # Create new repository directories
        foreach ($repo in $repoObjects) {
            $repoPath = "$PSScriptRoot/../../../$($repo.name)"
            
            if (Test-Path $repoPath) {
                Add-MigrationDetail -Phase "reorganization" -Message "Repository directory exists: $($repo.name)" -Status "Warning"
            }
            else {
                New-Item -ItemType Directory -Path $repoPath -Force | Out-Null
                Add-MigrationDetail -Phase "reorganization" -Message "Created directory: $($repo.name)" -Status "Success"
            }
            
            # Initialize as git repository
            Push-Location $repoPath
            git init 2>&1 | Out-Null
            
            # Create README.md
            $readmeContent = @"
# $($repo.name)

$($repo.description)

## Migration Information
- Migrated from: $SourceRepository
- Migration date: $(Get-Date -Format 'yyyy-MM-dd')
- Original location: $OrganizationUrl/$ProjectName/_git/$SourceRepository

## Purpose
$($repo.purpose)
"@
            Set-Content -Path "README.md" -Value $readmeContent
            
            # Create .azuredevops directory for pipelines
            New-Item -ItemType Directory -Path ".azuredevops" -Force | Out-Null
            
            # Create basic .gitignore
            $gitignoreContent = @"
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.pytest_cache/

# Azure ML
*.pkl
*.joblib
mlruns/
outputs/

# IDEs
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
"@
            Set-Content -Path ".gitignore" -Value $gitignoreContent
            
            Pop-Location
            
            Add-MigrationDetail -Phase "reorganization" -Message "Initialized repository: $($repo.name)" -Status "Success"
        }
        
        Add-MigrationDetail -Phase "reorganization" -Message "Repository structure created" -Status "Success"
        Add-MigrationDetail -Phase "reorganization" -Message "⚠️  Manual file migration required - see PROPOSED_STRUCTURE.md for mapping" -Status "Warning"
        
        $migrationState.phases.reorganization.status = "Completed"
        $migrationState.phases.reorganization.endTime = Get-Date
        
        Write-Host "  ✅ Repository reorganization completed" -ForegroundColor Green
        Write-Host "  ⚠️  Note: You need to manually move files from source to target repositories" -ForegroundColor Yellow
    }
    catch {
        $migrationState.phases.reorganization.status = "Failed"
        $migrationState.phases.reorganization.endTime = Get-Date
        Add-MigrationDetail -Phase "reorganization" -Message "Reorganization failed: $_" -Status "Error"
        $migrationState.errors += "Reorganization phase failed: $_"
        Write-Host "  ❌ Reorganization failed" -ForegroundColor Red
    }
    
    Write-Host ""
}

# ===== PHASE 3: CREATE AZURE DEVOPS REPOSITORIES =====
if (-not $SkipAzureDevOps) {
    Write-Host "[Phase 3: Create Azure DevOps Repositories]" -ForegroundColor Yellow
    $migrationState.phases.azureDevOps.status = "InProgress"
    $migrationState.phases.azureDevOps.startTime = Get-Date
    
    try {
        $targetRepos = $config.azureDevOps.targetRepositories
        
        foreach ($repo in $targetRepos) {
            $repoName = $repo.name
            
            # Check if repository exists
            $existingRepo = az repos show --repository $repoName --organization $OrganizationUrl --project $ProjectName 2>$null
            
            if ($existingRepo) {
                Add-MigrationDetail -Phase "azureDevOps" -Message "Repository already exists: $repoName" -Status "Warning"
                $repoJson = $existingRepo | ConvertFrom-Json
                $migrationState.repositories += @{
                    name = $repoName
                    id = $repoJson.id
                    url = $repoJson.webUrl
                    status = "AlreadyExists"
                }
            }
            else {
                Add-MigrationDetail -Phase "azureDevOps" -Message "Creating repository: $repoName"
                
                $newRepo = az repos create `
                    --name $repoName `
                    --organization $OrganizationUrl `
                    --project $ProjectName `
                    --output json
                
                if ($LASTEXITCODE -eq 0) {
                    $repoJson = $newRepo | ConvertFrom-Json
                    Add-MigrationDetail -Phase "azureDevOps" -Message "Created repository: $repoName" -Status "Success"
                    
                    $migrationState.repositories += @{
                        name = $repoName
                        id = $repoJson.id
                        url = $repoJson.webUrl
                        status = "Created"
                    }
                    
                    # Wait a moment for repository to be ready
                    Start-Sleep -Seconds 2
                }
                else {
                    throw "Failed to create repository: $repoName"
                }
            }
        }
        
        $migrationState.phases.azureDevOps.status = "Completed"
        $migrationState.phases.azureDevOps.endTime = Get-Date
        
        Write-Host "  ✅ Azure DevOps repositories created" -ForegroundColor Green
    }
    catch {
        $migrationState.phases.azureDevOps.status = "Failed"
        $migrationState.phases.azureDevOps.endTime = Get-Date
        Add-MigrationDetail -Phase "azureDevOps" -Message "Azure DevOps repository creation failed: $_" -Status "Error"
        $migrationState.errors += "Azure DevOps phase failed: $_"
        Write-Host "  ❌ Repository creation failed" -ForegroundColor Red
    }
    
    Write-Host ""
}

# ===== PHASE 4: CREATE SERVICE CONNECTIONS =====
if (-not $SkipPipelines) {
    Write-Host "[Phase 4: Create Service Connections]" -ForegroundColor Yellow
    $migrationState.phases.serviceConnections.status = "InProgress"
    $migrationState.phases.serviceConnections.startTime = Get-Date
    
    try {
        # Get service principal details from configuration
        if (-not $config -or -not $config.PSObject.Properties.Name -contains "servicePrincipal" -or -not $config.servicePrincipal.appId) {
            Add-MigrationDetail -Phase "serviceConnections" -Message "Service Principal not found in config - skipping" -Status "Warning"
            Add-MigrationDetail -Phase "serviceConnections" -Message "Run resource-creation skill to create SP with federated credentials" -Status "Warning"
            $migrationState.phases.serviceConnections.status = "Skipped"
            $migrationState.phases.serviceConnections.endTime = Get-Date
            Write-Host "  ⚠️  Service Principal not configured - run resource-creation skill first" -ForegroundColor Yellow
            Write-Host ""
        }
        else {
        
        $spAppId = $config.servicePrincipal.appId
        $tenantId = $config.azure.tenantId
        $subscriptionId = $config.azure.subscriptionId
        
        # Get subscription name from config or Azure CLI
        if ($config.PSObject.Properties.Name -contains "subscriptionName" -and $config.azure.subscriptionName) {
            $subscriptionName = $config.azure.subscriptionName
        }
        else {
            $subscriptionName = az account show --query name --output tsv
            Add-MigrationDetail -Phase "serviceConnections" -Message "Subscription name resolved: $subscriptionName"
        }
        
        $serviceConnectionName = "Azure-Production"
        
        # Check if service connection exists
        $existingConnections = az devops service-endpoint list `
            --organization $OrganizationUrl `
            --project $ProjectName `
            --output json | ConvertFrom-Json
        
        $existingConnection = $existingConnections | Where-Object { $_.name -eq $serviceConnectionName }
        
        if ($existingConnection) {
            Add-MigrationDetail -Phase "serviceConnections" -Message "Service connection already exists: $serviceConnectionName" -Status "Warning"
            $migrationState.serviceConnections += @{
                name = $serviceConnectionName
                id = $existingConnection.id
                status = "AlreadyExists"
            }
        }
        else {
            Add-MigrationDetail -Phase "serviceConnections" -Message "Creating service connection: $serviceConnectionName"
            Add-MigrationDetail -Phase "serviceConnections" -Message "Using workload identity federation (no secrets)"
            Add-MigrationDetail -Phase "serviceConnections" -Message "Subject: sc://$($OrganizationUrl.Split('/')[-1])/$ProjectName/$serviceConnectionName"
            
            # Create service connection with workload identity federation
            # Note: Azure CLI doesn't fully support federated credentials yet
            # This may require manual completion in the portal
            $newConnection = az devops service-endpoint azurerm create `
                --name $serviceConnectionName `
                --azure-rm-service-principal-id $spAppId `
                --azure-rm-subscription-id $subscriptionId `
                --azure-rm-subscription-name $subscriptionName `
                --azure-rm-tenant-id $tenantId `
                --organization $OrganizationUrl `
                --project $ProjectName `
                --output json 2>&1
            
            if ($LASTEXITCODE -eq 0) {
                $connectionJson = $newConnection | ConvertFrom-Json
                Add-MigrationDetail -Phase "serviceConnections" -Message "Service connection created successfully" -Status "Success"
                
                # Grant access to all pipelines
                Add-MigrationDetail -Phase "serviceConnections" -Message "Granting access to all pipelines..."
                az devops service-endpoint update `
                    --id $connectionJson.id `
                    --enable-for-all true `
                    --organization $OrganizationUrl `
                    --project $ProjectName `
                    --output none
                
                Add-MigrationDetail -Phase "serviceConnections" -Message "Access granted to all pipelines" -Status "Success"
                
                $migrationState.serviceConnections += @{
                    name = $serviceConnectionName
                    id = $connectionJson.id
                    status = "Created"
                }
            }
            else {
                Add-MigrationDetail -Phase "serviceConnections" -Message "Service connection creation failed (may need manual setup)" -Status "Warning"
            }
        }
        
            $migrationState.phases.serviceConnections.status = "Completed"
            $migrationState.phases.serviceConnections.endTime = Get-Date
            
            Write-Host "  ✅ Service connections configured" -ForegroundColor Green
        }
    }
    catch {
        $migrationState.phases.serviceConnections.status = "Failed"
        $migrationState.phases.serviceConnections.endTime = Get-Date
        Add-MigrationDetail -Phase "serviceConnections" -Message "Service connection creation failed: $_" -Status "Error"
        $migrationState.errors += "Service connections phase failed: $_"
        Write-Host "  ⚠️  Service connection creation failed (may require manual setup)" -ForegroundColor Yellow
    }
    
    Write-Host ""
}

# ===== PHASE 5: CREATE VARIABLE GROUPS =====
if (-not $SkipPipelines) {
    Write-Host "[Phase 5: Create Variable Groups]" -ForegroundColor Yellow
    $migrationState.phases.variableGroups.status = "InProgress"
    $migrationState.phases.variableGroups.startTime = Get-Date
    
    try {
        # ML Configuration Variable Group
        $mlGroupName = "ML-Configuration"
        
        # Check if variable group exists
        $existingMlGroup = az pipelines variable-group list `
            --organization $OrganizationUrl `
            --project $ProjectName `
            --query "[?name=='$mlGroupName'].id" `
            --output tsv 2>$null
        
        if ($existingMlGroup) {
            Add-MigrationDetail -Phase "variableGroups" -Message "Variable group already exists: $mlGroupName" -Status "Warning"
            $migrationState.variableGroups += @{
                name = $mlGroupName
                id = $existingMlGroup
                status = "AlreadyExists"
            }
        }
        else {
            Add-MigrationDetail -Phase "variableGroups" -Message "Creating variable group: $mlGroupName"
            
            $mlGroup = az pipelines variable-group create `
            --name $mlGroupName `
            --variables `
                mlWorkspace="$($config.azure.mlWorkspaceName)" `
                resourceGroup="$($config.azure.resourceGroupName)" `
                location="$($config.azure.location)" `
                subscriptionId="$($config.azure.subscriptionId)" `
            --authorize true `
            --organization $OrganizationUrl `
            --project $ProjectName `
            --output json 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            $mlGroupJson = $mlGroup | ConvertFrom-Json
            Add-MigrationDetail -Phase "variableGroups" -Message "Created: $mlGroupName" -Status "Success"
            $migrationState.variableGroups += @{
                name = $mlGroupName
                id = $mlGroupJson.id
                status = "Created"
            }
        }
        else {
            Add-MigrationDetail -Phase "variableGroups" -Message "ML group creation failed" -Status "Warning"
        }
        }
        
        # OpenAI Configuration Variable Group
        $openAIGroupName = "OpenAI-Configuration"
        
        # Check if variable group exists
        $existingOpenAIGroup = az pipelines variable-group list `
            --organization $OrganizationUrl `
            --project $ProjectName `
            --query "[?name=='$openAIGroupName'].id" `
            --output tsv 2>$null
        
        if ($existingOpenAIGroup) {
            Add-MigrationDetail -Phase "variableGroups" -Message "Variable group already exists: $openAIGroupName" -Status "Warning"
            $migrationState.variableGroups += @{
                name = $openAIGroupName
                id = $existingOpenAIGroup
                status = "AlreadyExists"
            }
        }
        else {
            Add-MigrationDetail -Phase "variableGroups" -Message "Creating variable group: $openAIGroupName"
            
            $openAIGroup = az pipelines variable-group create `
            --name $openAIGroupName `
            --variables `
                openaiService="$($config.azure.openAIServiceName)" `
                openaiDeploymentGPT4="gpt-4o" `
                openaiDeploymentGPT4Mini="gpt-4o-mini" `
                location="$($config.azure.location)" `
            --authorize true `
            --organization $OrganizationUrl `
            --project $ProjectName `
            --output json 2>&1
        
            if ($LASTEXITCODE -eq 0) {
                $openAIGroupJson = $openAIGroup | ConvertFrom-Json
                Add-MigrationDetail -Phase "variableGroups" -Message "Created: $openAIGroupName" -Status "Success"
                $migrationState.variableGroups += @{
                    name = $openAIGroupName
                    id = $openAIGroupJson.id
                    status = "Created"
                }
            }
            else {
                Add-MigrationDetail -Phase "variableGroups" -Message "OpenAI group creation failed" -Status "Warning"
            }
        }
            $openAIGroupJson = $openAIGroup | ConvertFrom-Json
            Add-MigrationDetail -Phase "variableGroups" -Message "Created: $openAIGroupName" -Status "Success"
            $migrationState.variableGroups += @{
                name = $openAIGroupName
                id = $openAIGroupJson.id
                status = "Created"
            }
        }
        else {
            Add-MigrationDetail -Phase "variableGroups" -Message "OpenAI group creation failed" -Status "Warning"
            }
        }
        
        $migrationState.phases.variableGroups.status = "Completed"
        $migrationState.phases.variableGroups.endTime = Get-Date
        
        Write-Host "  ✅ Variable groups created" -ForegroundColor Green
    }
    catch {
        $migrationState.phases.variableGroups.status = "Failed"
        $migrationState.phases.variableGroups.endTime = Get-Date
        Add-MigrationDetail -Phase "variableGroups" -Message "Variable group creation failed: $_" -Status "Error"
        $migrationState.errors += "Variable groups phase failed: $_"
        Write-Host "  ⚠️  Variable group creation failed (may require manual setup)" -ForegroundColor Yellow
    }
    
    Write-Host ""
}

# ===== PHASE 6: CREATE PIPELINES =====
if (-not $SkipPipelines) {
    Write-Host "[Phase 6: Create CI/CD Pipelines]" -ForegroundColor Yellow
    $migrationState.phases.pipelines.status = "InProgress"
    $migrationState.phases.pipelines.startTime = Get-Date
    
    try {
        Add-MigrationDetail -Phase "pipelines" -Message "Pipeline creation requires YAML files in repositories"
        Add-MigrationDetail -Phase "pipelines" -Message "Skipping automatic pipeline creation - create manually or after code push" -Status "Warning"
        
        # Note: We'll create pipeline YAMLs in the repositories, but won't create the actual pipelines
        # until the code is pushed to Azure DevOps
        
        $migrationState.phases.pipelines.status = "Skipped"
        $migrationState.phases.pipelines.endTime = Get-Date
        
        Write-Host "  ⚠️  Pipeline creation skipped - create after pushing code" -ForegroundColor Yellow
    }
    catch {
        $migrationState.phases.pipelines.status = "Failed"
        $migrationState.phases.pipelines.endTime = Get-Date
        Add-MigrationDetail -Phase "pipelines" -Message "Pipeline creation failed: $_" -Status "Error"
        $migrationState.errors += "Pipelines phase failed: $_"
        Write-Host "  ❌ Pipeline creation failed" -ForegroundColor Red
    }
    
    Write-Host ""
}

# ===== PHASE 7: VALIDATION =====
if (-not $SkipValidation) {
    Write-Host "[Phase 7: Validation]" -ForegroundColor Yellow
    $migrationState.phases.validation.status = "InProgress"
    $migrationState.phases.validation.startTime = Get-Date
    
    try {
        # Validate repositories
        Add-MigrationDetail -Phase "validation" -Message "Validating repositories..."
        $repos = az repos list --organization $OrganizationUrl --project $ProjectName --output json | ConvertFrom-Json
        Add-MigrationDetail -Phase "validation" -Message "Total repositories: $($repos.Count)" -Status "Success"
        
        # Validate service connections
        Add-MigrationDetail -Phase "validation" -Message "Validating service connections..."
        $connections = az devops service-endpoint list --organization $OrganizationUrl --project $ProjectName --output json | ConvertFrom-Json
        Add-MigrationDetail -Phase "validation" -Message "Total service connections: $($connections.Count)" -Status "Success"
        
        # Validate variable groups
        Add-MigrationDetail -Phase "validation" -Message "Validating variable groups..."
        $varGroups = az pipelines variable-group list --organization $OrganizationUrl --project $ProjectName --output json | ConvertFrom-Json
        Add-MigrationDetail -Phase "validation" -Message "Total variable groups: $($varGroups.Count)" -Status "Success"
        
        $migrationState.phases.validation.status = "Completed"
        $migrationState.phases.validation.endTime = Get-Date
        
        Write-Host "  ✅ Validation completed" -ForegroundColor Green
    }
    catch {
        $migrationState.phases.validation.status = "Failed"
        $migrationState.phases.validation.endTime = Get-Date
        Add-MigrationDetail -Phase "validation" -Message "Validation failed: $_" -Status "Error"
        $migrationState.errors += "Validation phase failed: $_"
        Write-Host "  ❌ Validation failed" -ForegroundColor Red
    }
    
    Write-Host ""
}

# ===== FINAL REPORT =====
$migrationState.endTime = Get-Date
$duration = $migrationState.endTime - $migrationState.startTime

Write-Host "╔══════════════════════════════════════════════════════════════╗" -ForegroundColor Cyan
Write-Host "║                   Migration Summary                          ║" -ForegroundColor Cyan
Write-Host "╚══════════════════════════════════════════════════════════════╝" -ForegroundColor Cyan
Write-Host ""

Write-Host "Duration: $($duration.ToString('hh\:mm\:ss'))" -ForegroundColor Gray
Write-Host ""

Write-Host "Phase Status:" -ForegroundColor Yellow
foreach ($phase in $migrationState.phases.Keys | Sort-Object) {
    $status = $migrationState.phases.$phase.status
    $icon = switch ($status) {
        "Completed" { "✅" }
        "Failed" { "❌" }
        "Skipped" { "⚠️" }
        default { "⏸️" }
    }
    $color = switch ($status) {
        "Completed" { "Green" }
        "Failed" { "Red" }
        "Skipped" { "Yellow" }
        default { "Gray" }
    }
    Write-Host "  $icon $phase : $status" -ForegroundColor $color
}

Write-Host ""
Write-Host "Resources Created:" -ForegroundColor Yellow
Write-Host "  Repositories: $($migrationState.repositories.Count)" -ForegroundColor Gray
Write-Host "  Service Connections: $($migrationState.serviceConnections.Count)" -ForegroundColor Gray
Write-Host "  Variable Groups: $($migrationState.variableGroups.Count)" -ForegroundColor Gray
Write-Host "  Pipelines: $($migrationState.pipelines.Count)" -ForegroundColor Gray

if ($migrationState.errors.Count -gt 0) {
    Write-Host ""
    Write-Host "Errors: $($migrationState.errors.Count)" -ForegroundColor Red
    foreach ($error in $migrationState.errors) {
        Write-Host "  ❌ $error" -ForegroundColor Red
    }
}

# Save migration report
$reportPath = "$PSScriptRoot/../../../$OutputReport"
$migrationState | ConvertTo-Json -Depth 10 | Out-File -FilePath $reportPath -Encoding UTF8
Write-Host ""
Write-Host "Migration report saved to: $OutputReport" -ForegroundColor Cyan

Write-Host ""
Write-Host "╔══════════════════════════════════════════════════════════════╗" -ForegroundColor Green
Write-Host "║              Migration Execution Complete                    ║" -ForegroundColor Green
Write-Host "╚══════════════════════════════════════════════════════════════╝" -ForegroundColor Green
Write-Host ""

Write-Host "Next Steps:" -ForegroundColor Yellow
Write-Host "  1. Review the migration report: $OutputReport" -ForegroundColor Gray
Write-Host "  2. Push code to newly created repositories" -ForegroundColor Gray
Write-Host "  3. Create CI/CD pipelines for each repository" -ForegroundColor Gray
Write-Host "  4. Test service connections and variable groups" -ForegroundColor Gray
Write-Host "  5. Configure branch policies and permissions" -ForegroundColor Gray
Write-Host ""
